### 운영체제란?

운영체제란 응용프로그램 또는 사용자가 컴퓨터 하드웨어를 편리하고 효율적으로 사용하게 하기 위하여 시스템 자원(메모리, 프로세서 등)을 관리하고 여러가지 프로그램이 필요로 하는 공통적인 서비스를 제공하는 소프트웨어이다.

 

컴퓨터를 부팅한다 = 운영체제가 메모리에 올라가서 기능한다. (운영체제는 항상 실행되는 프로그램과 같다)

<br><br>               
### 운영체제의 목적

1. 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공

 - 동시 사용자가 각각 독자적으로 컴퓨터를 쓰는것과 같은 환상을 제공 (한대의 서버를 공유한다고 가정 시)

 - 또는, 한 사용자가 음악/ 게임/ 웹서핑을 동시에 실행가능한 환경
<br><br> 
 

2. 컴퓨터 시스템의 자원을 효율적으로 관리 (CPU, Memory) 

 - 컴퓨터 자원은 CPU, I/O장치, 메모리 등으로 이루어짐 (CPU는 컴퓨터의 두뇌)

 - 하나의 CPU를 짧은 시간간격으로 여러 프로그램에 번갈아 할당하며, 개별 프로그램 입장에서는 혼자 CPU를 독식하는듯 함.

 - 실행 중인 프로그램들에 메모리 공간을 적절히 분배

> 메모리는 CPU의 작업 공간. 프로그램이 실행되려면 반드시 프로그램을 메모리에 올려놓아야 함. 어떤 프로그램을 얼마큼의 메모리에 올려놓아야 하는지 운영체제가 계산 및 실행. CPU 스케줄링은 운영체제를 통해 이루어짐
- 이로서 최대한의 성능을 발휘하도록 하는것이 효율성 달성의 수단.

- 형평성 또한 중요함. 형평성이란 효율성을 너무 극대화하는 과정에서 특정 사용자나 프로그램에 지나친 불이익이 발생하지 않도록 하는것.

 

 
<br><br> 
### 컴퓨터 시스템의 구조
컴퓨터 내부 : 메모리 + CPU <br>
컴퓨터 외부 : I/O device (input/output) = 하드디스크, 키보드, 마우스, 프린터기, 모니터 등
=> 하드디스크는 input, output 모두 담당가능. 본질적으로 컴퓨터 외부 구조에 해당함.

 

 
<br><br> 
### 운영체제의 기능
 

1. CPU 스케줄링

CPU는 매 클럭마다 메모리의 기계어를 읽어서 실행하며 프로세스는 CPU 사용을 위해 CPU 큐에 쌓임. CPU 스케줄링이란 CPU의 시간을 분할하여 쓰는 time sharing을 하는 방식.
<br><br> 
**Shortest Job First**
- 프로세스가 먼저 온 순서대로 처리하는 것보다, 시간이 덜 걸리는 프로세스를 앞에 할당하는 것이 전체 평균시간이 줄어듦. 

- 그러나 이는 효율성은 좋지만 형평성은 좋지 않음. 긴 프로세스가 뒤로 밀리는 현상이 발생하기 때문.
<br><br> 
**Round Robin**
- 각 프로세스가 동일 크기의 CPU 할당 시간을 가지도록 함.

- 할당 시간 종료 후 인터럽트가 발생하여 CPU가 다음 프로세스에 넘어감. 해당 프로세스는 CPU 큐 맨 뒤에 줄을 섬.

 = 따라서, 어떠한 프로세스도 (n-1) * 할당시간 이상 기다리지 않음.

 = 대기 시간은 CPU 사용시간에 비례함.

 
<br><br> 
2. 메모리 관리

- CPU의 작업공간은 메모리임. 따라서 디스크(I/o)에서 어떤 파일을 불러와야 하는 상황에서, 파일을 디스크에서 바로 가져와 읽는것이 아님.

- 프로그램들이 메모리에 올라갈 때, 동등하게 n분의 1의 공간을 차지하지는 않음. 이를 효율적으로 사용하는것이 메모리관리.

- 여러 프로그램이 메모리에 올라가 있는것을 multiprogramming이라고 함.

- I/O마다 작은 CPU가 하나씩 붙어있음. 이를 I/o 컨트롤러라고 함.

- 이 컨트롤러가 CPU의 주문에 따라서 필요한 파일을 메모리에 올려놓게 됨.

- 이때 실행파일이 메모리에 바로 올라가는것이 아니라 가상메모리가 생성됨. 이 가상메모리에서 당장 필요한 부분만 물리적인 메모리에 올려놓게 됨. 메모리가 다 차면 당장 필요하지 않은 부분은 스왑영역 디스크에 올라감.

- 따라서 스왑영역은 메모리의 연장공간

- 컴퓨터가 꺼지면 메모리는 휘발되고, 스왑영역은 살아있으나 의미가 없음!

- 어떤 페이지(파일)를 스왑영역으로 쫓아낼지에 대한 우선순위를 정할 때 :
<br><br> 
**LRU(Least recently used)** : 가장 오래전에 참조된 페이지를 삭제<br>
**LFU(Least frequently used)** : 사용된 횟수가 가장 적은 페이지를 삭제
<br><br> 
- 미래를 모르는 상황에서 '미래에 다시 사용될 가능성이 낮은 페이지'를 스왑영역으로 쫓아내는 것이 메모리 관리의 핵심.

 

 
<br><br> 
3. 디스크 스케줄링 

- 디스크는 CPU나 메모리에 비해 굉장히 느림. 

- 여러 프로그램이 CPU를 번갈아가며 쓰듯이, I/O장치에도 요청이 여러 프로그램으로부터 번갈아 도착해서 디스크 큐에 쌓임.

- 이렇게 디스크를 읽어달라는 요청이 여러 프로그램에서 왔을 때 먼저 요청된 순서대로 동작하면 굉장히 비효율적임.

- 이러한 순서를 재배치하는것이 디스크 스케줄링 (= 엘리베이터 버튼 동작과 비슷함!)

- 요청에 따른 디스크 헤드의 이동시간을 줄이는 것이 관건.

현재 위치에서 가장 가까운 요청번호를 처리하도록 함. > 효율성은 좋으나 형평성은 안좋음
'Scan' : 헤드가 디스크의 한쪽 끝에서 반대쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리하는 방법 > 현재 사용되는 방법.     

<br><br> 
4. 인터럽트 / 캐싱

- CPU와 메모리, I/o장치의 속도차이를 완충하기 위함

- 캐싱 : 똑같은 데이터를 디스크에서 또 읽어야 할 때, 이전과 같은 프로세스로 디스크에 도달하지 않고 메모리 어딘가에 보관해놓았다가 이를 사용하는 개념.

- 인터럽트 : CPU는 매우 빠르기 때문에 매 요청을 수행시키고 나서 CPU는 이후 당장 시행할 수 있는 것을 찾음. 이는 CPU스케줄링의 일환임. 또한 CPU가 시킨 일을 다 했을때 이를 인터럽트로 알려줌. CPU는 매번 기계어 처리도 하지만 인터럽트 체크도 시행함.

 

 

 
<br><br> 
### 운영체제의 분류
 
<br><br> 
**동시작업 가능 여부**

단일 작업 : 한번에 하나의 작업만 처리

다중 작업 : 동시에 두개 이상의 작업을 처리

 
<br><br> 
**사용자의 수**

단일 사용자 : (Windows)

다중 사용자 : 한대의 컴퓨터에 여러 사용자가 터미널 형태로 동시 접속하여 쓸 수 있음

<br><br>  

**처리 방식**

1. 일괄처리

- 작업 요청을 일정량 모아서 한꺼번에 처리

- 작업이 완전 종료될 때까지 기다려야 함.

 

2. 시분할

- 여러 작업을 수행할 때 컴퓨터 처리 능력을 일정 단위로 분할하여 사용함.

- 각 사용자가 컴퓨터로부터 서비스 제공받는 시간을 숫자로 표시 (다중사용자 운영체제)

- 인터렉티브함

- 우리가 사용하는 운영체제 처리방식!

 

3. 실시간 

- 데드라인이 존재하며, 이를 반드시 만족해야 하는 시스템.

- 예 : 원자로 제어, 미사일 제어, 반도체/로보트 제어 등

 

 
<br><br> 
### 운영체제의 예
<br>
1. 유닉스

- 큰 서버를 위한 운영체제 (다중 사용자, 다중 작업)

- C언어로 만들어서 사람이 이해하기가 편리 > 수정작업도 편리.

- 공개 소스코드 / 다양한 버전

- 프로그램 개발에 용이

 <br>

2. MS windows

- 다중작업용 GUI기반 운영체제

- 풍부한 지원 소프트웨어

<br>
3. 모바일 운영체제 - Android, iOS
